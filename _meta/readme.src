# How to use anise

Each anise-aware project needs to have a *project description* file, which contains metadata about the project as well
as some task implementations, e.g. for interaction with your other tools (requesting a certain piece of information
from some version control system, building an executable with some compiler, ...).

## What is a 'project description' file?

The project description file must be either in the root directory of your project or in
the `_meta/` subdirectory and must be named `_projectdesc`. All task definitions and every relevant piece of information
about your project are noted in this file. The complete anise operation will run just on top of it (this
is not entirely correct, but correct enough for the moment :-P).

This file will be evaluated as Python code at runtime. It contains mostly this kinds of expressions:

- Simple assignments for simple scalar metadata, like the project name, the license of your project or the email
  address for contacting the developer team. Example: `name = "Anise"`

- Some more complex kinds of project metadata, like software dependencies or package creation information are calls
  to functions.
  Example: `distributables.pool.addgroup(packaging.tasks.tarpackage, name="source tarball")`

- Task definitions. They specify how to actually finish a certain task like generating packages or the documentation.
  This definitions will be executed either directly (if this is the task you call the engine with), indirectly, or
  not at all. There are two different ways to define tasks (and an additional one):

  - Write your own task implementation in very much the same way as you would write functions directly in Python code.
    Example: `def makefoo(...): //and some lines of Python code`

  - Just do an assignment from something from the `tasks` object, which contains the tasks currently provided by
    anise itself or some of the loaded plugins (a.k.a. features).
    Example: `makedeveloperdoc = documentation.tasks.makedeveloperdoc_doxygen`

## Executing tasks

What the user of anise does, after creating a `_projectdesc` file, is executing the tasks defined in that file. You do
so by calling
anise **from the project root directory** on the command line. In the easiest case, you just need to give the task's
name as the only parameter. Assuming to have defined a `dorelease` task, you can simply call

\verbatim
anise dorelease
\endverbatim

from the project directory.

## Technical details about the anatomy of anise

### The 'project object'

Conceptually, there is one global data structure, which contains all the information for executing tasks. This includes
all the metadata, like the project's name, its license and so on, as well as all task implementations. This data
structure is called 'the *project* object'. A `project` in source code, nearly always refers to it. Each piece of metadata and
each task implementation is stored in a property of this object. For example, `project.name` maybe contains the name
of the project.

Technically, this project object can be accessed in different ways:

- Each assignment in the `_projectdesc` file directly sets a value for one property. This makes it syntactically easy
  and short to set metadata there. Each line in the following example sets the value for one property of the project
  object:

\verbatim
name = "anise"
license = licensing.GPLv3
makehomepage = homepage.tasks.makehomepage  # a task definition
\endverbatim

  Please note that this does only work for direct assignments, not for indirect ones, e.g. within a function:

\verbatim
def sometask():
    name = "anise"  # this will never assign anything to the project
                    # object! We will see a workaround some lines below.
\endverbatim

- From all places in Python code, it is possible to add the line `from anise.framework import projects` to the imports
and get the current project with `projects.currentproject()` like this:

\verbatim
projects.currentproject().email = "jen@reynholm-industries.co.uk"
\endverbatim

  or

\verbatim
projects.currentproject().email = foo_getusername() + "@" + foo_getmaildomain()
\endverbatim

Please note that `projects` is automatically imported into the execution context of the `_projectdesc` file, so you
can directly access the project object from within functions this way:

\verbatim
def sometask():
    projects.currentproject().name = "anise"
\endverbatim

* On the command line, anise can be executed with additional parameters in order to assign values to properties of the
  project object (this is limited to textual values), like this:

\verbatim
anise dorelease --setvalue 'license' 'MS-EULA'  # just for this call, i'm a fan of a redmond license
\endverbatim

#### A larger example

The following will give a simple, but more overall example for how the value assignments on the project object can
be used to actually do useful things (the example itself - surprise, surprise - will again just print some nonsense).

Assume the following `_projectdesc` file in your project:

\verbatim
targetname = "peace in the world"
author = "john"
end_of_sentence = "."

def get_formatted_authorname():
    return "<" + projects.currentproject().author + ">"

def get_formatted_targetname():
    return "<" + projects.currentproject().targetname + ">"

def do_something(project):
    part1 = project.get_formatted_authorname(project)
    part2 = project.get_formatted_targetname(project)
    part3 = project.end_of_sentence
    print ("The major goal of " + part1 + " is " + part2 + part3)
\endverbatim

And the following command line:

\verbatim
anise do_something --setvalue 'end_of_sentence' ' :D'
\endverbatim

The execution of that call will print the following text:

\verbatim
The major goal of <john> is <peace in the world> :D
\endverbatim

### Task implementations

A task implementation is just a definition of a Python function. There are two different kinds of task
implementations:

- Task implementations without function parameters. They can directly be called from the command line by the
  name of the function in your Python code.

- Task implementations which have parameters. They can't be called from the command line, but can be used as helpers
  for others tasks.

Please note that directly calling a task from the command line only makes sense if it returns reasonable types of
values. The anise engine understands returning the primitive data types and many more:

- Everything which has a meaningful implementation of `__str__`.

- An instance of anise.framework.results.Filestructure. This is used for returning pieces of the filesystem (i.e. single
  files or directories with all its contents).

This is an example for a task, which can directly be used by an end user via a command line call:

\verbatim
def some_directly_usable_task():  # needs 'thumb' to be set to a number in the project object
    return math.pi * projects.currentproject().thumb  # a german phrase equivalent to the
                                                      # english 'rule of thumb approximation'
\endverbatim

### The parts of anise

- Anise is built as a very generic infrastructure. In basic parts, it was used in all the example above. It provides
  some more parts, though it is rather stupid. It mostly executes Python code and provides some convenience.

- There is a plugin mechanism, called 'features'. Each feature brings some encapsulated additional
  functionality to anise. Read below more about features. All high-level functionality of anise is encapsuled in
  such 'features'.

- And there is a place for plain functions with simple arguments and output, not
  bound to any part of the framework or any feature. Those are utility functions used at some other parts of anise.

Now some details follow about those three parts.

#### The anise infrastructure

The infrastructure (the active part is anise.framework.engine btw) executes Python code in a `_projectdesc` file and
makes some syntactical tricks leading to shorter (and better readable) files. This tricks include the direct
access to the project object and the automatic imports it makes before executing `_projectdesc`.

It also helps tasks creating file structures at temporary places and return them completely or partially to the
caller and it provides also much more convenience functionality. Read about anise.framework if you are interested.

However, as mentioned, the high-level functionality is not implemented here, but in the 'features'.

\anchor _features

#### Features

All high-level functionality provided by anise is implemented in a bunch of 'features', which are something like
plugins for anise. They can either provide additional tasks, which your `_projectdesc` file can use somehow,
or it can bind some functions to hooks (more details about this in the developer section; it is something like an event)
in order to actively execute additional services.

One part of the generic infrastructure is the features handler anise.framework.features. It loads additional features
at the beginning of execution.

The developer section below explains, what a feature is in detail (and some hints how to develop one).

#### Utilities

The utility functionality is put into the anise.utils package. It can be small convenience things and also rather
complex routines. All of them are uncoupled from anise infrastructure, so they could be used in other programs.

## Technical details

### The hook system

An important part for the philosophy of anise is the hook system. It is also the basis of the working of features.

A hook is something like an event. Interesting parties can bind functions to this event. Other parties can iterate
over the bound functions at certain moments - mostly in order to execute them.

A hook has a unique name in anise. The name is the identifier used to bind to it or iterate over it. Both can be
done anywhere in a task implementation:

\verbatim
def bartask():  # we will bind this function to a hook below
    print("hello world")

def footask():
    projects.currentproject().addhook("MYHOOK", bartask) # binding a function to "MYHOOK"
\endverbatim

\verbatim
def sometask():
    for hook in projects.currentproject().gethooks("MYHOOK"):
        hook()      # iterating and executing the hook "MYHOOK"
\endverbatim

Providing such a hook (which is not a defined technical process, since a hook is just a name) and iterating/executing
it at certain moments (also called events) is a way to provide functionality which other parties can use by binding
stuff to that hook.

Binding stuff to a hook, vice versa, is a way to participate on some external functionality.

Note: Using string literals as hook keys this way is unsafe. You should avoid doing this! There should be a constant
defined somewhere for each hook.

There are some hooks defined by the engine itself, which have such defined constants. They are defined in
anise.framework.features:

- `HOOK_BEFORE_DEFINITION`: executed by the engine just before the `_projectdesc` file itself is read/executed
- `HOOK_BEFORE_EXECUTION`: executed by the engine just before the chosen task ifself is executed

You would correctly used them this way:

\verbatim
def bartask():  # we will bind this function to a hook below
    print("hello world")

def footask():
    projects.currentproject().addhook(anise.framework.features.HOOK_BEFORE_DEFINITION, bartask)
\endverbatim

This was about hooks, which will later be used in the sections about features.

### What features are and how they are implemented

Anise features are what elsewhere probably would be called 'plugins'. Each feature encapsulates a certain set of
functionality in one Python module file with some class and function definitions. All this items are imported
in a new Python module. This module is automatically available in the project object, so this way you can use a function
of a feature directly in `_projectdesc` (as with everything in the project object):

\verbatim
name = "anise"
...
somefeature.somefunction(42) # calls 'somefunction' from feature 'somefeature'
...
\endverbatim

The items are available in a full-qualified manner, prepended with the full feature name. The full feature name is
given by the file path of the feature source file. By the way: Full feature names can also be longer, like
`name.space.some.feature`.

#### Providing functions directly

With the way above a feature can provide an interface which is callable from `_projectdesc` for controlling the behavior of
the feature. This means setting configuration values or adding several items into some lists, which are
processed later on by the feature logic later on, for instance.

Example: The `homepage` feature provides `homepage.sections.add` as interface, so other parties can add sections
of content to the project homepage in the building process.

#### Providing classes

A feature can also export classes instead of functions in order to provide a class-based interface, so `_projectdesc`
can instantiate them:

\verbatim
name = "anise"
...
somefeature.somefunction(somefeature.SomeClass(foo=42, 1, 2, 3))
...
\endverbatim

#### Binding to infrastructure-hooks

For actively providing services, a function can be bound to a hook from the infrastructure (for other hooks, we
need another trick). Those are `HOOK_BEFORE_DEFINITION` and more; introduced above. Use a function decorator for binding
a function to such a hook:

\verbatim
@features.hook(features.HOOK_BEFORE_DEFINITION)
def _initproject():
    projects.currentproject().myunittests = []  # initialize, so later usage won't fail
\endverbatim

This will automatically be executed at a very early stage of anise execution and can prepare some stuff.

#### Binding to non-infrastructure-hooks (and exporting own ones)

Other hooks, which are not defined in the infrastructure (but by another feature), are trickier. Technically they
can be used by a string literal, as mentioned before. This method does not recognize broken references, however.
For solving this issue, there is a mechanism for features to export hooks which it actively interates at times,
and for other features to safely refer to them.

Exporting is easy, just prepend a string variable with `HOOK_` in some of your lines in the features file. It looks
like this:

\verbatim
def foo():
    ...
...
HOOK_DOSOMETHING = "DOSOMETHING"
\endverbatim

This will automatically detected by the feature loader and exported for external usage. The own code in this feature
should of course use the same variable.

Binding to a non-infrastructure hook can't be done via function decorators but must be done in Python code. It must
look up the feature by name, which provides a hook. Then it can use the returned data structures this way:

\verbatim
@features.hook(features.HOOK_BEFORE_DEFINITION) # this is NOT the interesting hook here!
def _initproject():

    def foo():
        do_something(1)
        do_something(2)
        do_something(3)

    projects.currentproject().addhook(features.loadfeature("myfeature").featuremodule.HOOK_DOSOMETHING, foo)
\endverbatim

The large line adds a hook to project object. For the hook name, it searches the feature `myfeature` and accesses
the `HOOK_DOSOMETHING` hook.

#### Exporting task implementations

Last but not least is exporting task implementation one of the common deals of a feature. Task implementations
are simple functions, which are supposed to be called as task from command line (or indirectly somewhere from the
called task). This differs from the functions mentioned above, which are called directly at the root level of
`_projectdesc`.

A task implementation can be used by binding it to a nice name ...
\verbatim
makehomepage = homepage.tasks.makehomepage
\endverbatim
... and call that from command line:
\verbatim
$ anise makehomepage
\endverbatim

One can also call tasks from within other parts. This implementation of `makehomepage` would work nice as well:

\verbatim
def makehomepage():
    print("i start making the homepage")
    projects.currentproject().homepage.tasks.makehomepage()
    print("i finished making the homepage")
\endverbatim

A feature provides tasks (by convention) by providing the class `tasks` with only static methods, like here:

\verbatim
def foo(): # not so interesting here
    ...
...
class tasks:

    @staticmethod
    def sometask():
        ...
\endverbatim

If this feature is named `somefeature` (i.e. its file is `somefeature.py` directly in an anise feature loading path)
a `_projectdesc` can use it this way

\verbatim
dosomething = somefeature.tasks.sometask
\endverbatim

so one can call it from command line this way:

\verbatim
$ anise dosomething
\endverbatim

This are the basic recipes for implementing features.

## The command line options

\copydoc commandline
